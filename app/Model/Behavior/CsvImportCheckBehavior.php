<?php

App::uses('CsvImportBehavior', 'Utils.Model/Behavior');

/**
 * Extending CsvImportBehavior to add a check function to determine if the row should be
 * saved or not based on the new callback
 */
class CsvImportCheckBehavior extends CsvImportBehavior {

/**
 * Hold the array of rows skipped
 * @var array
 */
	public $skippedRows = array();

/**
 * Returns a list of keys representing the columns of the CSV file, using a check callback to
 * determine if the row should be saved or not before validation
 *
 * @param Model &$Model model
 * @param string $file path to the CSV file
 * @param array $fixed data to be merged with every row
 * @param bool $returnSaved true to return
 * @throws RuntimeException if $file does not exists
 * @return mixed boolean indicating the success of the operation or list of saved records
 */
	public function importCSV(Model &$Model, $file, $fixed = array(), $returnSaved = false) {
		if (empty($file)) {
			return false;
		}
		$handle = new SplFileObject($file, 'rb');
		$header = $this->_getHeader($Model, $handle);
		$db = $Model->getDataSource();
		$db->begin($Model);
		$saved = array();
		$i = 0;
		while (($row = $this->_getCSVLine($Model, $handle)) !== false) {
			$data = array();
			foreach ($header as $k => $col) {
				// get the data field from Model.field
				if (strpos($col, '.') !== false) {
					list($model, $field) = explode('.', $col);
					$data[$model][$field] = (isset($row[$k])) ? $row[$k] : '';
				} else {
					$data[$Model->alias][$col] = (isset($row[$k])) ? $row[$k] : '';
				}
			}
			$data = Set::merge($data, $fixed);
			$rowData = $data;
			$Model->create();
			$Model->id = isset($data[$Model->alias][$Model->primaryKey]) ? $data[$Model->alias][$Model->primaryKey] : false;

			//beforeImport callback
			if (method_exists($Model, 'beforeImport')) {
				$data = $Model->beforeImport($data);
			}
			//skipRowImport callback
			$message = null;

			if (method_exists($Model, 'skipRowImport') && $message = $Model->skipRowImport($rowData)) {
				$this->skippedRows[$Model->alias][$i] = $message;
				$i++;
				continue;
			}

			$error = false;
			$Model->set($data);
			if (!$Model->validates()) {
				//obs: skippedRows is being counted based in how many erros the file has.
				$this->skippedRows[$Model->alias][$i] = $message;
				$this->errors[$Model->alias][$i]['validation'] = $Model->validationErrors;
				$error = true;
				$this->_notify($Model, 'onImportError', $this->errors[$Model->alias][$i]);
			}

			// save the row
			if (!$error && !$Model->saveAll($data, array('validate' => false, 'atomic' => false))) {
				$this->errors[$Model->alias][$i]['save'] = sprintf(__d('utils', '%s for Row %d failed to save.'), $Model->alias, $i);
				$error = true;
				$this->_notify($Model, 'onImportError', $this->errors[$Model->alias][$i]);
			}

			if (!$error) {
				$this->_notify($Model, 'onImportRow', $data);
				if ($returnSaved) {
					$saved[] = $i;
				}
			}

			$i++;
		}

		$success = empty($this->errors);
		if (!$returnSaved && !$success) {
			$db->rollback($Model);
			return false;
		}

		$db->commit($Model);

		if ($returnSaved) {
			return $saved;
		}

		return true;
	}

/**
 * Returns the skipped rows generated by last import
 *
 * @param Model &$Model model
 * @return array
 */
	public function getImportSkippedRows(Model &$Model) {
		if (empty($this->skippedRows[$Model->alias])) {
			return array();
		}
		return $this->skippedRows[$Model->alias];
	}
}
